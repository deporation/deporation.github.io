---
layout:     post                    # 使用的布局（不需要改）
title:      排序算法               # 标题 
date:       2019-12-04              # 时间
author:     deporation                      # 作者
header-img: img/2019-12-4.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:
    - 数据结构                               #标签
---
# 1. 排序
```C
    typedef strcut
    {

    }ElemType;
    low()//想下取整
    high()//向上取整
```
## 1.1 插入排序
>- 1.1 插入排序
>  - 1.1.1 直接插入排序
>  - 1.1.2 折半插入排序
>  - 1.1.3 希尔排序
### 1.1.1 直接插入排序
> 思想：
>   已经排序好的|哨兵|未排序的
> --|:--:|--:
> 有序序列L[1……i-1] |L[i]|无序序列L[i+1……n]
> 1. 查找出L(i)在L[1……i+1]中的插入位置k
> 2. 将L[k……i-1]中所有的元素全部后移一个位置
> 3. 将L(i)复制到L(k)


```C
    void InsertSort(ElemType A,int n)
    {
        int i,j;
        for(i=2 ;i <= n; i++)//依次将A[2]~A[n]插入到前面已排序列
            if(A[i].key<A[i - 1].key)//若A[i]的key小于其前驱，需要将A[i]插入有序表
            {
                A[0] = A[i];//复制为哨兵，A[0]不存放元素
                for(j = i - 1;A[0].key < A[j].key; --j)//从后往前查找待插入位置
                    A[j+1] = A[j];//向后挪位
                A[j+1] = A[0];//复制到插入位置
            }
    }
```
空间复杂度：O(1)

时间复杂度：最好情况下O(n),最差情况下，比较次数：∑(i=2,n)(i), 移动次数∑(i=2,n)(i+1),平均复杂度：O(n^2)
***
### 1.1.2 折半插入排序（仅限顺序表）
***
> 思想：
> 1. 先折半找出元素的待插入位置
> 2. 统一的一定带插入位置之后的元素
```C
    void InsertSort(ElemType A[], int n )
    {
        int i,j,low,high,mid;
        for(i = 2;i <= n; i++) //依次将A[2]~A[n]插入前面的已排序序列
        {
            A[0] = A[i];//将A[i]暂时的到A[0]
            low = 1;high = i -1;//设置折半查找的范围
            while(low <= high)//开始查找
            {
                mid = (low+high/2);//取中间点下标
                if(A[mid].key > A[0].key ) high = mid -1;//查找左半子表
                else low = mid + 1;//查找右半子表
            }
            for (j= i-1;j >= high; --j)
                A[j+1] = A[j];//统一后移元素，空出插入位置
            A[high+1] = A[0];//插入操作
        }
    }
```
空间复杂度：O(1)

时间复杂度: O(n^2)
***

### 1.1.3 希尔排序
***
> 思想：
> 1. 将待排序表分割成若干形如L[i,i + d,i + 2d,……,i + kd]的子表
> 2. 分别进行直接插入排序
> 3. 当整个表中的元素已呈“基本有序时”，再对全体进行一次直接插入排序。
```C
    void ShellSort(ElemType A[],int n)
    {
        //对顺序表做希尔插入排序，本算法和直接插入排序相比，做了如下修改
        //1.前后记录的增量是dk，而不是1
        //A[0]只是暂存但愿，不是哨兵，当j <= 0，插入位置已到
        for(dk = n/2 ;dk >= 1 ; ++i)//步长变化
            for(i = dk + 1; i<= n ; ++i)
                if(A[i].key < A[i - dk])//需将A[i]插入有序增量子表
                {
                    A[0] = A[i];//暂存在A[0]
                    for(j = i - dk;j > 0 && A[0].key < A[j].key;j-=dk)
                        A[j+dk] = A[j];//记录后移，查找插入位置
                    A[j+dk] = A[0];//插入
                }
    }
```
***
## 1.2 交换排序
> - 1.2 交换排序 
>   -  1.2.1 冒泡排序
>   -  1.2.2 快速排序
### 1.2.1 冒泡排序
> 思想：
> 1. 假设待排序表长位n，从前往后两两比较相邻的元素值，若为逆序，则交换他们
> 2. 下一趟冒泡的时候，前一趟确定的最小元素不在参与比较，待排序列减少一个元素，每趟冒泡结果是把序列中减少一个元素，每趟冒泡把序列中最小的元素放在最终位置上
```C
    void BubbleSort(ElemType A[], int n)
    {
        for(i = 0;i < n - 1;i++)
        {
            flag = false;//表示本趟冒泡是否发生交换的标志
            for(j = n-1;j > i;j--)//一趟冒泡的过程
                if(A[j-1].key > A[j].key)//若为逆序
                {
                    swap(A[j-1],A[j]);//交换
                    flag  = true;
                }
                if(flag == false)
                    return ;//本趟遍历后没有发生交换，说明表已经有序
        }
    }
```
空间效率：O(1)

时间效率：最好的情况下时间复杂度O(n),最坏的情况下时间复杂度位O(n^2),平均时间复杂度也为O(n^2)
***
### 1.2.2 快速排序
> 思想：
> 1. 在待排序表L[1……n]中任取一个元素pivot作为基准，通过一趟排序将待排序表划分为独立两个部分L[1……k-1]和L[k+1……n],使得L[1……k-1]中所有元素小于pivot的，L[k+1……n]中所有的元素大于等于pivot，则pivot放在其最终位置上L(k),这个过程称作一趟快拍顺序。
> 2. 分别递归的队两个子表重复上述过程，直至每部分内只有一个元素或为空为止，即所有的元素放在了其最终位置上。

**程序结构如下**
```C
    void QuickSort(ElemType A[], int low, int high)
    {
        if(low < high)//跳出递归的条件
        {
            //Partition()为划分操作，将表A[low……high]划分满足上述条件的两个子表
            int pivotpos = Partition(A,low,high);//划分
            QuickSort(A,low,pivotpos-1);//依次堆两个子表进行递归排序
            QuickSort(A,pivotpos+1,high);
        }
    }
```
**严蔚敏快排划分法**
>   假设每次以当前表中第一个元素作为枢轴值来对表进行划分，则必须将表中比枢值大的元素向右移动，将比枢轴值笑的元素向左移动，使得一趟Partition()之后，表中元素被枢轴一分为二
```C
    int Partition(ElemType A[],int low,int high)
    {
        ElemType pivot - A[low];
        while(low < high)
        {
            while(low<high && A[high]<= pivot) ++low;
            A[high] = A[low];
        }
        A[low] = pivot;
        return low;
    }
```
***
## 1.3 选择排序
> 基本思想：
>  第i趟在后面n-i+1(i=1,2,……,n-1)个待排元素选择关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个，就不用再选了
> - \
>   - 1.3.1 简单选择排序
>   - 1.3.2 堆排序 
***
### 1.3.1 简单选择排序
>思想：假设排序表为L[1……n]，第i趟排序即从L[i……n]中关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过n-1趟排序就可使得整个排序表有序。
```C
    void SelectSort(ElemType A[],int n)
    {
        for(i = 0;i < n-1;i++)//一共n-1趟
        {
            min = i;//记录最小的元素
            for(j =i + 1;j < n;j++)//在A[i……n-1]中选择最小的元素
                if(A[j] < A[min])   min = j;//更新最小元素的位置
            if(min != i)    swap(A[i],A[min]);//与第i个位置进行交换
        }
    }
```
空间效率：O(1)

时间效率:O(n^2)

为不稳定排序
***
### 1.3.2 堆排序
>思想：堆排序的关键是构造初始堆。n个结点的完全二叉树，最后一个结点是第low(n/2)个结点的孩子。对第low(n/2)个结点为根的子树筛选(对于大根堆，若根节点的关键字小于左右孩子中关键字较大者，则交换) ，使该子树成为堆。之后向前依次对各结点(low(n/2)-1~1)为根的子树进行少选，看结点指是否大于其左右结点的值，若不大于，则将左右子节点中的较大值与之进行交换，交换后可能破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该节点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根节点。

**建立大根堆的算法**
```C
    void BuildMaxheap(ElemType A[],int len)
    {
        for(int i = len/2;i > 0;i--)//从i=[n/2]~1,反复调整堆
            AdjustDown(A,i,len);
    }
    void AdjustDown(ElemType A[],int k,int len)
    {
        //函数AdjustDown将元素k向下调整
        A[0] = A[k];//A[0]暂存
        for(i = 2*k;i <= len;i*=2)//沿key较大的子节点向下筛选
        {
            if(i < len && A[i] < A[i+1])
                i++;//取key较大的子节点下标
            if(A[0] >= A[i])    break;//筛选结束
            else
            {
                A[k] = A[i];//将A[i]调整到双亲结点上
                k = i;//修改k值
            }
        }//for
        A[k] = A[0];
    }
    //以下为向上调整堆的算法
    void AdjustUp(ElemType A[],int k)
    {
        A[0] = A[k];
        int i = k/2;//若结点值大于双亲结点，则将双亲结点向下调，并继续向上比较
        while(i > 0 && A[i] < A[0])//循环跳出条件
        {
            A[k] = A[i];//双亲结点下调
            k = i;
            i = k/2;//继续向上比较
        }//while
        A[k] = A[0];//复制到最终位置
    }
```
**堆排序算法**
```C
    void HeapSort(ElemType A[],int len)
    {
        BuildMaxHeap(A,len);//建立初始堆
        for(i = len ;i > 1;i--)//n-1趟的交换和建堆过程
        {
            swap(A[i],A[1]);//输出堆顶元素(和堆底元素交换)
            AdjustDwon(A,1,i-1);//整理，把剩余的i-1个元素整理成堆
        }//for
    }
```
性能分析：

空间效率：O(1)

时间效率：建立堆的时间为O(n),之后有n-1次向下调整的操作，每次调整的时间复杂度为O(h)，故在最好和最坏的情况下，堆排序的时间复杂度为O(nlog<span font-size =1px>2</span>n)